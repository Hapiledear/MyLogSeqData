- SQL语句是声明式的，只说了它要什么样的答案，而没有说为了获得答案需要经历怎样的过程。
- 通过DBMS的优化器自动地去对SQL语句进行查询优化，有如下两种方式，两种策略都会被用于查询优化。
- Heuristics / Rules 启发式/基于规则
	- 通过一些规则/变换的手段(等价的关系代数表达式)，优化掉用户的查询语句里面低效的部分
	- 需要查询相关的元数据（catalog，比如说需要知道有没有给某个attribute构建索引），不需要检查数据本身（比如说获取数据的统计信息）
- Cost-based Search 基于代价
	- 通过构建一些代价模型，来计算查询如果按照某个计划去做的话相应的代价是多少
	- 通过比较多个计划的代价，从中选出代价最小的计划去执行
		- 为了计算出代价，往往需要知道数据库所存储的数据的一些统计信息（比如说数据的规模）
- SQL请求的执行流程
  collapsed:: true
	- ![image.png](../assets/image_1716881056955_0.png)
	- 1 and 2 用户的业务会发出SQL查询语句，少部分DBMS会有SQL Rewriter这个组件，对字符串形式的SQL语句进行文本上的预处理
	- 2 to 4 Parser会把SQL语句变成抽象语法树，抽象语法树当中会涉及到库/表/列的名称，这些名称要和数据库系统元数据里面的库/表/列/索引的ID对应上，因此会有Binder（即连接器）把SQL抽象语法树中用户写的表名/列名/索引名转化成数据库内部使用的ID
	- 5 经Binder处理过之后的抽象语法树会被送入Tree Rewriter，这个组件大多数DBMS都有，它会输出一个标准的执行计划，这个过程中也会查一些系统的元数据，Tree Rewriter输出的原始的逻辑计划是优化器进行优化的源头
		- 比如说SQL语句里有一堆join操作，一开始的抽象语法树中的join的排布可能是乱的，Tree Rewriter会把所有的join排列成左深树，这个步骤也叫正则化
	- 6 基于规则的优化器（RBO， rule based optimizer）会查询一些系统的元数据来做优化，基于代价的优化器（CBO， cost based optimizer）不仅会查询元数据，还会查询相关的代价模型，根据代价模型去做优化，最后优化器会生成物理计划，被实际使用
- 逻辑执行计划 VS. 物理执行计划 Logical Plans VS. Physical Plans
	- 逻辑计划是**关系代数**级别的，物理计划包括了各个算子的**具体执行方式**(比如说join算子是用nested-loop join还是merge/hash join来完成)
	- 逻辑表达式和物理算子未必是1对1的（比如我使用了sort merge join ，就可以取消 order by 表达式了)
- 查询优化属于NP-Hard问题（NP是非多项式的意思），甚至都不一定能得出最优解，是DBMS最难的部分。目前最新的研究中甚至引入了机器学习来辅助查询优化，但这样的人工智能模型有些时候是不可解释的，是一个黑盒
- 关系代数表达式的等价 Relation Algebra Equivalences
	- 如果两个关系代数表达式所输出的结果集是一样的，那么它们等价
	- 即使没有cost 模型，DBMS也可以找到更好的逻辑执行计划，这一过程称作 查询重写(query rewriting)
-