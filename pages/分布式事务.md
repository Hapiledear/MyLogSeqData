- [[分布式事务面试题]]
- 事务存在的意义是为了保证系统中所有的书籍都是符合预期的，且不会产生矛盾。即数据的 **一致性**。 而要达成这个目标，就需要三方面的共同努力
	- 原子性：对多个数据的修改，要么同时成功，要么同时被撤销。
	- 隔离性：各自业务正在读、写的数据互相独立，不会彼此影响。
	- 持久性：所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。
- 本地事务
	- 仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。简单来说，就是 单个服务使用单个数据源。
	- 它的实现方式通常依赖于底层的 数据引擎，如MySQL中的InnoDB。
	- 通过双写日志的形式，保证原子性和持久性
	- 通过MVCC机制和锁机制 保证隔离性
- 全局事务
	- 单个服务使用多个数据源场景。
	- 存在的问题 ```
	  public void buyBook(PaymentBill bill) {
	      userTransaction.begin();
	      warehouseTransaction.begin();
	      businessTransaction.begin();
	  	try {
	          userAccountService.pay(bill.getMoney());
	          warehouseService.deliver(bill.getItems());
	          businessAccountService.receipt(bill.getMoney());
	          userTransaction.commit(); //1
	          warehouseTransaction.commit(); //2
	          businessTransaction.commit(); //3
	  	} catch(Exception e) {
	          userTransaction.rollback(); //1
	          warehouseTransaction.rollback(); //2
	          businessTransaction.rollback(); //3
	  	}
	  }
	  ```
	- 事务3提交失败，将会执行到catch代码块，可此时事务1,2均已成功提交，即使执行了rollback()方法也无济于事。
	- 为解决上述问题，**XA**协议将事务提交拆分为两阶段过程，因此也称为”两段式提交“ **2PC**.
		- ![image.png](../assets/image_1690795580265_0.png)
		- **准备阶段**: 协调者询问事务的所有参与者是否准备好提交,参与者可以回复 Prepared 和 Non-Prepared. 它与本地事务中真正提交的区别只是**暂不写入最后一条 Commit Record** 而已
		- **提交阶段**: 协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；**否则**，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。
		- 对于数据库来说，提交操作仅仅只有一条指令，通常能够快速完成。而回滚操作则需要清除已提交的数据，相对耗时。
		- 协调者、参与者都是可以由数据库自己来扮演的，而app相对于数据库来说只是client角色。协调者一般是在参与者之间**选举**产生。
		-
	- 两段式提交原理简单，并不难实现，但有几个非常显著的**缺点**：
		- **单点问题**：协调者等待参与者回复时可以有超时机制，允许参与者宕机协调者本身宕机而一直没有恢复，所有参与者都会受到影响。
		- **性能问题**：
- 分布式事务