- 简介
	- 当今互联网交易,完全依赖于金融机构作为可信的第三方来处理交易内容.如 支付宝,微信支付.基于该信任模型,会产生如下缺点
		- 1. 金融机构的仲裁成本,增加了交易成本,限制了最小实际交易额度. 信用成本上升
		  2. 为了防范欺诈,商家必须更加警惕他们的客户,希望搜集更多的非必要信息. 过度信息收集,泄露风险.
	- 本论文旨在创建一个不需要可信任第三方的交易系统,基于密码学原理,使用程序化合约的方式,保证交易在计算上的不可撤销.
- 交易 & 时间戳
	- 数字签名
		- 数据经过 [[哈希函数]] 所算出来的一串字符串.即使数据内容只被改动一个字母,得出的哈希结果依旧相差甚远.
		- 例如,A向B借款1千元,并打下借条 `5月1日,A向B借款 一千元 整,约定10月1日归还`. 那么可以生成一串数字签名,A和B各一份.待到归还时,A需要验证B对借条内容有无篡改,则只需要再次加密一遍,拿着结果与手中的数字签名比对即可.
	- 数字签名链
		- 将链条中,`前一节点的哈希值+当前节点的数据+ 交易发生时间` 一起计算. 这样就能把所有数据串成一串.按交易发生时间排序.
		- 随着时间的推移,链条越来越长.前一节点的可信度也就越来越高.因为伪造的成本会更大.
		- 这样做的好处是,在对方没有保存初始哈希的情况下,让对方相信数据没有被篡改
		- 例如,需要让陌生人C相信A与B的借款协议没有被篡改.那么,需要如下步骤
			- 1. 前提条件,C不知道借款协议的原始数据,也不知道原始哈希值.而该协议是存在H链上的一个节点H_a
			  2. 但是,C会定期拉去H链上的最新节点H_max,保存在本地.他的所有本地副本集合,称为H_t
			  3. 那么,C可以 比较自己的集合H_t 与H链上对于的节点,没有被窜改 -> H链没有被窜改 -> H_a没有被窜改
			- ![image.png](../assets/image_1663486099030_0.png)
- 区块
	- 将哈希链条按照时间进行分割(eg. 10分钟一段),每一段就称之为一个区块.一个区块含有不等的交易数据.
	- 注意,我们是**多节点**的**分布式**系统,将链条分割成多段,每一段以其中一个节点为准.这样,用户在上传数据时,并不会 由于网络延迟原因,**生成不同顺序的数据链条**.
	- 到底哪一个节点说了算?
		- 哪一个节点率先拿到了某一段的"话语权",就是该节点说了算.
		- 在BTC中,则是 率先计算出符合条件的新区块的节点 说了算.对应后文的 工作量证明 和 共识机制
	- 如何运作的?
		- 拿到话语权的节点,将该区块内部的哈希链条顺序,广播给所有节点,做到数据同步.
		- 同时,计算出整个的哈希值,用以验证数据完整性.
	- 为什么以时间为划分依据?
		- 如果按数据长度来划分,随着数量的增大,每段生成的时间需要越来越短,短到 几毫秒,几微秒.远低于信息传播时间,无法响应过来.
- 区块内部的结构
	- 采用链式结构,会存放许多不必要的数据.随着数据量的增大,其验证成本也会增大
	- step1. 数据与哈希值解耦
		- ![image.png](../assets/image_1663489002949_0.png)
	- step2. 使用 [[默克尔树]],消除中间哈希值
		- ![image.png](../assets/image_1663489046339_0.png)
	- 最终,我们的区块变成了这样
		- ![image.png](../assets/image_1663489283986_0.png)
	- 这样,我们只需要同步 根哈希值 和 所有叶子节点的数据 即可.
		- 根哈希值 在节点获得话语权 时,向外广播.
		- 所有叶子节点数据,在节点计算新区块时,就会一直接收.
	- 在验证交易的正确性时,也只需验证它的一个子树即可.
		- eg. 验证 交易4 的正确性
		- Hash 1-8 -> Hash 1234 & Hash 5678 -> Hash 34 & Hash 12-> Hash 4 & Hash 3
	- 这种 **不需要获取完整交易副本** 的特性,将会用到后文中的 合并和分割交易额
- 工作量证明
	- 定义
		- 在做一件主要的事情A之前,先做一件事情b.自己必须付出一定的成本,以此向外传递一个 自己是可以信任的 信号.
		- 它传递的是一种信号,旨在提升 资源转换为信任的效率.
		- 关键点
			- 1. 事情b不能太重,但一定要占用(消耗)一定的资源.
			  2. 大量的做事情b会**付出高额的成本**
		- 对于我们的H链来讲,**改变区块H_a需要重做所有后面的区块**,成本将异常的高昂.
		- 在BTC中,工作量证明的手段是 找到一个哈希结果是前n位为0的值.
	- 工作量的难度
		- 随着科技的发展和市场的逐渐完备,投入到H链中的总算力是不断增长的.当计算出一个区块的难度不变时,产生新区块的频率会上升.
		- 频率上升,意味着 投入计算节点的平均成本会下降.也意味着做坏事的成本下降了.
		- 同时,频率上升,意味着 每个区块所记录的数据量变少了.
		- 在BTC中,采用 移动平均数法,来对生成区块的难度进行动态调整
			- `新难度值 = 旧难度值 * (过去x个区块总时长/y小时)`
- 网络 & 共识机制
	- 角色
		- 客户端
			- 普通用户使用的终端设备,两项功能
			- 从节点同步区块头
			- 上传数据
		- 服务节点
			- 保存数据,计算区块和同步区块.
			- 节点之间相互连接,不存在中心节点
	- 计算阶段(节点)
		- 不断接收数据包,填充到默克尔树的底端
		- 不断尝试随机数,努力凑出满足目标的哈希值
		- 将新数据包不断广播给其他节点
		- ![image.png](../assets/image_1663490595874_0.png)
	- 同步阶段(节点)
		- 率先打出有效包的节点,广播部分区块信息(区块头,默克尔树的树枝)
		- 接收者依据树枝底部Hash值排序数据,并验证区块头.
		- 超半数接收者认同了该区块,开始竞争下一区块.
		- ![image.png](../assets/image_1663490614216_0.png)
	- 共识1: 节点总数认为最长的链为正确的并持续致力于延长它
		- 短时间内,可能存在两条相同长度的链,此时节点将他们都保存.当下一个区块被找到后,僵局就会被打破.在另一分支上工作的节点将切换到更长的链上来.
		- 长链上汇聚的算力会远超短链,更容易延长.
- 虚拟币 与 激励政策
	- 为什么要发币?
		- 客户购买存证服务,要充值虚拟币,再用币支付.
		- 节点收到虚拟币,为客户提供存证服务. 虚拟币就与现时法币挂钩,有了价格.
		- ![image.png](../assets/image_1663491763908_0.png)
	- 虚拟币可以做到全球统一,所有节点公认.因此,不能允许节点擅自增发虚拟币
		- 防止手段 上传数据时必须附带一张符合格式的“支票”,写明了付款金额和手续费.
	- 为什么需要激励政策?
		- 整个系统发展的前期,收益较低,需要补发津贴,激励节点工作.
		- 币的总量恒定 -> 不会通胀贬值
			- 虚拟币不能也不会替代法币
		- 基于以上两点,因此需要一个指数衰减型的激励政策.
	- 节点通过工作量证明获取区块收入的行为就可以被称为“挖矿”，挖矿的节点就可以被称为“矿工”。
- 交易 Transation
	- 一次交易,需要包含6条信息, 假设 用户B 转账给了C ,C 再给了D
		- 交易单号
		- 资金来源(上一交易单号)
		- 资金去向(D的公钥)
		- 资金数额
		- C的签名
	- ![image.png](../assets/image_1663493273059_0.png)
	- ![image.png](../assets/image_1663493688564_0.png)
	-
- 隐私
	- 每个参与交易的人,都持有一对 公\私钥
		- 私钥 用于对上传信息进行签名.
		- 公钥 用于 对方对签名进行验证.
	- 公众能够看到有人正在发送一定量的货币给其他人,但是不能将交易关联到某个人. 即 交易行情是公开的,但是不会显示交易双方是谁.