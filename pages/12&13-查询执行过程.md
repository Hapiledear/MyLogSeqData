-
- 多索引扫描 Multi-Index Scan
	- 使用age字段的索引，把`age<30`的记录筛选出来；同时也使用dept字段的索引，把`dept='cs'`的人筛选出来。之后取他们的交集，再从交集中选取出`country='US'`的记录。
	- 取交集的过程可以通过#bitmap #哈希表 /#布隆过滤器 等实现。
	- ![image.png](../assets/image_1716704683516_0.png)
	- 在[[Postgres]]中，称作#BitmapScan
- 索引扫描后的按页排序 Index Scan Page Sorting
	- 在使用#非聚簇索引 查找数据时，得到的结果集是乱序的，在接下来的二次回表中，就会造成多次的IO读取，效率不高。
	- DBMS首先找出它所需的tuples(#晚物化 )，再将它们按照PageId进行一次排序。这样可以减少一定的IO次数。
- 表达式求值 Expression Evaluation
	- SQL中的Where块以及join On 块，共同构成了表达式树 expression tree
	- 树中的节点有如下5类
		- 比较运算符(=,<,>,!=)
		- AND 和 OR
		- 数学运算符(+,-,*,/,%)
		- 常量Constant和变量Parameter
		- 对tuple属性的引用，也就是表中的某一字段
	- 解析这棵树通常而言是低效的做法。DBMS必须遍历树中的每一个节点，执行每一步操作。
	- 另一种做法是将这颗树(甚至将整个查询计划)编译成机器码，如JIT(#即时编译器 )一般，执行速度更快。
- 并行查询
	- 为什么需要并行查询？
		- 提高吞吐量(能够处理更多的用户请求)
		- 降低对用户的响应延迟
		- 提升系统的可用性
		- 降低总成本
		  collapsed:: true
			- 使劲压榨CPU的性能从而降低机器等硬件成本
	- 并行与分布式 Paraller VS. Distributed
		- 共同点
			- 需要使用到多份资源来实现
			- 使用者不关心实际的物理组织架构，就像是使用单机数据库(单线程单节点)一样使用它
		- 并行式数据库
			- 资源都集中在一台机器上
			- 资源之间的通信速度快
			- 通信过程十分简易、可靠
		- 分布式数据库
			- 资源之间可能间隔很远(在世界上的不同角落)
			- 资源之间的通信依托于较慢的网络
			- 通信过程中的耗时与问题无法被忽略(即使概率小，一定会发生)
		- 访问模型 Process Models
			- DBMS的**process model**描述的是多个用户的查询请求是如何并发执行的
			- **worker**是DBMS中用来执行任务task的组件
				- 比如，一份查询计划可以被分为多个task，交由多个worker去执行
			-
-