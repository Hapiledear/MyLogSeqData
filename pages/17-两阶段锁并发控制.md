- 上一节中所介绍的判断执行调度是否满足冲突可串行化的方法需要等到执行调度里所包括的多个事务都**执行完之后**才能判断出这个执行调度是否可串行化。但等到执行调度所包括的事务全都执行完并提交了之后，它们就都已经完成了对DBMS的更新，如果这个执行调度是不可串行化的，那么DBMS的一致性就会被破坏，因此这种检测可串行化的方式是**无济于事**的。
- 相应的解决方法是我们用锁来保护数据库中的被共享的对象，从而避免数据竞争。
- Lock
	- Lock保护的不是具体的数据结构，而是数据库的抽象的内容，比如说向锁管理器申请的可以是对数据库的表的某一行的锁，这个锁会保护涉及这一行的所有的索引里面关于这一行的部分。
	- 先获取Lock，在对这个逻辑对象内部的数据结构实际进行操作时再获取Latch。
- 两种Lock
	- S-Lock: 共享锁，读锁
	- X-Lock: 排他锁，写锁
- 在带有Lock的情况下，事务执行的过程
	- 事务获取锁(更新锁)
	- 锁管理器授权或阻塞事务
	- 事务释放锁
	- 锁管理器更新内部的lock-table
		- lock-table负责记录哪些事务持有锁，哪些事务仍在等待
- 普通的加锁，并不能保证本次调度的执行结果正确，需要一些额外的规则限制
- 二阶段锁 Two-Phase Locking
	- 二阶段锁是一个并发控制协议，它规定了一个事务在运行的过程中如何跟其他事务之间协调锁，从而实现可串行化。
	- 使用两阶段锁不需要提前知道完整的执行调度，它会在调度进行的过程中避免不可串行化的情况发生.
	- 两个阶段
		-