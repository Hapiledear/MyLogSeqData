- 上一节中所介绍的判断执行调度是否满足冲突可串行化的方法需要等到执行调度里所包括的多个事务都**执行完之后**才能判断出这个执行调度是否可串行化。但等到执行调度所包括的事务全都执行完并提交了之后，它们就都已经完成了对DBMS的更新，如果这个执行调度是不可串行化的，那么DBMS的一致性就会被破坏，因此这种检测可串行化的方式是**无济于事**的。
- 相应的解决方法是我们用锁来保护数据库中的被共享的对象，从而避免数据竞争。
- Lock
	- Lock保护的不是具体的数据结构，而是数据库的抽象的内容，比如说向锁管理器申请的可以是对数据库的表的某一行的锁，这个锁会保护涉及这一行的所有的索引里面关于这一行的部分。
	- 先获取Lock，在对这个逻辑对象内部的数据结构实际进行操作时再获取Latch。
- 两种Lock
	- S-Lock: 共享锁，读锁
	- X-Lock: 排他锁，写锁
- 在带有Lock的情况下，事务执行的过程
	- 事务获取锁(更新锁)
	- 锁管理器授权或阻塞事务
	- 事务释放锁
	- 锁管理器更新内部的lock-table
		- lock-table负责记录哪些事务持有锁，哪些事务仍在等待
- 普通的加锁，并不能保证本次调度的执行结果正确，需要一些额外的规则限制
- 二阶段锁 Two-Phase Locking
	- 二阶段锁是一个并发控制协议，它规定了一个事务在运行的过程中如何跟其他事务之间协调锁，从而实现可串行化。
	- 使用两阶段锁不需要提前知道完整的执行调度，它会在调度进行的过程中避免不可串行化的情况发生.
	- 两个阶段
		- 阶段1：Growing
			- 事务只能不断地请求获得锁，不能释放锁
		- 阶段2：Shrinking
			- 事务只能释放锁，不能再获取新的锁
		- ![image.png](../assets/image_1718003475402_0.png){:height 241, :width 304}
	- 在使用了二阶段锁协议后，相应的执行调度对应的依赖图（Dependency Graph）一定没有环，二阶段锁可以严格地保证冲突可串行化
	- 但会出现 ((6666a76e-9c0e-45cf-962c-33b69d8934cf)) 的问题，解决方式是使用 ((6666a83a-aace-4db8-a531-c55396dad6e6))
	- 会导致死锁 deadlocks
- 级联回滚 Cascading Aborts
  id:: 6666a76e-9c0e-45cf-962c-33b69d8934cf
	- T1修改表A之后释放了A的锁，T2在T1的修改基础之上进行了修改。但T1最终需要Abort 回滚，那么T2就必须跟着T1一起回滚。
- 严格二阶段锁协议 Strong Strict 2PL
  id:: 6666a83a-aace-4db8-a531-c55396dad6e6
	- 事务所修改的数据在事务结束之前，其他事务都不能读写。它只比串行执行好那么一点点。
	- ![image.png](../assets/image_1718003948046_0.png){:height 174, :width 295}
-