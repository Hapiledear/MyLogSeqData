- 是一种乐观的并发控制方式。它的基本原理是，给每个事务一个时间戳，根据事务的时间戳来决定它们的顺序以及出现冲突操作时该如何处理。
- 如果事务Ti的时间戳在Tj之前，那么DBMS要保证这两个事务都被提交之后的效果相当于Ti先执行，Ti执行完了之后Tj再执行
- 时间戳分配 Timestamp Allocation
	- 对于每一个事务Ti，都会被分配到一个全系统唯一的并且是单调递增的时间戳。
	- 具体的实现策略有三种
		- 系统时钟
			- 缺点：需要每隔一段时间进行校准，站在本地机器的角度来看，会出现“突然被调慢了一分钟”的情况，导致时间戳顺序发生混乱
		- 逻辑计数器
		- 两者的混合(#雪花算法 ) 多用于分布式系统
- 时间戳排序协议 Timestamp Ordering(T/O) Protocol
	- 事务在读写时不加锁
	- 对每个对象X(每一条数据记录)，都额外附带两个时间戳，由上次成功的读/写操作更新
		- W-TS(x) 在ts时刻写入x
		- R-TS(x) 在ts时刻读取x
	- 每次读写前，都要检查这两个时间戳：比较当前事务的时间戳和将要进行读写的对象的时间戳，要求是“不能操作未来的数据”。
	- 读流程 Reads
		- 如果 `TS(Ti)<W-TS(X)`, 这就属于“操作来着未来的数据”了，当前事务Ti abort，之后系统再给这个事务一个新的时间戳，并重启事务。
		- 否则，就是合法的。
			- Ti可以读取对象x
			- 更新`R-TS(X) = max(R-TS(X),TS(Ti))`
			- copy对象x到事务本地，确保之后读取的x都是这份副本
				- 对象x可能接下来会被其他事务修改
	- 写流程 Writes
		- 如果 `TS(Ti) < R-TS(X)` or `TS(Ti)<W-TS(X)`, abort然后重启Ti
		- 否则
			- 对X进行写操作，并更新W-TS(X)
			- 也将其copy一份到事务本地
	- 优化：托马斯写规则 Thomas Write Rule
		-