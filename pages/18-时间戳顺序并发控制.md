- 是一种乐观的并发控制方式。它的基本原理是，给每个事务一个时间戳，根据事务的时间戳来决定它们的顺序以及出现冲突操作时该如何处理。
- 如果事务Ti的时间戳在Tj之前，那么DBMS要保证这两个事务都被提交之后的效果相当于Ti先执行，Ti执行完了之后Tj再执行
- 时间戳分配 Timestamp Allocation
	- 对于每一个事务Ti，都会被分配到一个全系统唯一的并且是单调递增的时间戳。
	- 具体的实现策略有三种
		- 系统时钟
			- 缺点：需要每隔一段时间进行校准，站在本地机器的角度来看，会出现“突然被调慢了一分钟”的情况，导致时间戳顺序发生混乱
		- 逻辑计数器
		- 两者的混合(#雪花算法 ) 多用于分布式系统
- 时间戳排序协议 Timestamp Ordering(T/O) Protocol
	- 事务在读写时不加锁
	- 对每个对象X(每一条数据记录)，都额外附带两个时间戳，由上次成功的读/写操作更新
		- W-TS(x) 在ts时刻写入x
		- R-TS(x) 在ts时刻读取x
	- 每次读写前，都要检查这两个时间戳：比较当前事务的时间戳和将要进行读写的对象的时间戳，要求是“不能操作未来的数据”。 ((666d7bb8-b76b-4a7c-a64a-57cdd9e59e27)) ((666d7d4c-a5f7-44cb-be4e-708f0ff5ed04))
	- 如果不考虑 ((666d7dd3-13b1-4d1c-baf0-1a6fdc0fe9c8))带来的优化，基础T/O协议会产生 ((66667615-6a45-4a8d-af11-3e216fd97f89))
		- 优点是不可能构成死锁，因为没有事务会进行等待
		- 缺点是 执行时间较长的事务(上白条SQL语句的批量操作)可能会“饥饿”；数据的copy会带来不小的开销
			- 长事务的饥饿：长事务执行了一段时间之后，想要访问的数据都是被比它更“年轻”的事物修改过的，那它只能abort，重启之后又迎来同样的结局
	- 基础T/O协议的执行调度是不可恢复的 ((666d7efa-2e63-4b9b-8538-5ca317562a80))
		- 很有可能一个长事务执行半天然后abort了,短事务都commit很多了
	- ------
	- 读流程 Reads
	  id:: 666d7bb8-b76b-4a7c-a64a-57cdd9e59e27
		- 如果 `TS(Ti)<W-TS(X)`, 这就属于“操作来着未来的数据”了，当前事务Ti abort，之后系统再给这个事务一个新的时间戳，并重启事务。
		- 否则，就是合法的。
			- Ti可以读取对象x
			- 更新`R-TS(X) = max(R-TS(X),TS(Ti))`
			- copy对象x到事务本地，确保之后读取的x都是这份副本
				- 对象x可能接下来会被其他事务修改
	- 写流程 Writes
	  id:: 666d7d4c-a5f7-44cb-be4e-708f0ff5ed04
		- 如果 `TS(Ti) < R-TS(X)` or `TS(Ti)<W-TS(X)`, abort然后重启Ti
		- 否则
			- 对X进行写操作，并更新W-TS(X)
			- 也将其copy一份到事务本地
	- 托马斯写规则 Thomas Write Rule
	  id:: 666d7dd3-13b1-4d1c-baf0-1a6fdc0fe9c8
	  collapsed:: true
		- 如果`TS(Ti) < R-TS(X)`,abort然后重启Ti
			- 说明比Ti更靠后的事务读取了该对象的值，不能让Ti进行写操作
		- 如果`TS(Ti)<W-TS(X)`
			- 比Ti更靠后的事务已经修改了该对象的值，如果不提交Ti修改记录也没事。等效于 Ti完成了写操作但被Tj的写操作覆盖了
		- 否则
			- 对X进行写操作，并更新W-TS(X)
- 乐观并发控制 OOC Opti
- ------
- 可恢复的执行调度 Recoverable Schedules
  id:: 666d7efa-2e63-4b9b-8538-5ca317562a80
	- 如果 事务在修改共享对象时，都是在其他事务已提交对共享对象的更新的基础上去修改，那么，这份调度就是可恢复的
	- 否则，DBMS很难保证在崩溃后恢复时数据的一致性
	- ![image.png](../assets/image_1718452687320_0.png){:height 217, :width 356}
-
-