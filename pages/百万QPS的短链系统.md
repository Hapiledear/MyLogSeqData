# 短链服务的好处
	- 缩短地址长度，留足空间给有意义的内容
		- 分享时的文字，推广链接时的广告词
	- 对原始URL内容进行管控
		- 通过用户的举报，将该链接在我们应用中禁止打开
	- 对原始URL进行行为分析
	- 短链不暴露访问参数，更安全。能规避关键词、域名屏蔽等手段
- # 短链的请求流程
	- 客户端 输入 短URL，访问服务端的短链服务
	- 服务端返回 对应的长链，并要求 客户端\\H5 进行 302重定向
	- 客户端访问长URL，进而访问 原始服务
- # 短链服务模块设计-- 发号、存储、映射
- ## 高并发的发号器
  id:: 66544683-504d-4344-a4e9-d0abfdb0bd53
	- 核心思想：1. 生成ID的速度 本地 >> 数据库和redis。2.  生成ID的唯一性 和 顺序性
	- ### 发号器的基础功能
		- 唯一ID--为每一个长地址分配一个号码ID (10进制,long类型)
		- 防止歧义--同一个长地址多次请求得到的短地址应是一样的
	- ### 方案一：Hash算法
		- 缺点：虽然概率极低，但还是会出现碰撞
		- 适用场景：简单的映射关系
	- ### 方案二：数据库自增ID
		- 单表情况下，直接使用数据库自增主键
		- 高并发情况下，给每台机器预分配ID区间，等到不足时再向DB请求下一区段
		- 缺点：1. 分库分表后，ID容易重复。2. 因为加事务和锁的原因，该部分容易成为瓶颈。
		- 适用场景：1. 单数据实例
	- ### 方案三：Redis生成ID
		- 通过Redis的INCR/INCRBY自增原子操作命令
		- 整体性能比数据库要高
		- 缺点：Redis宕机后找回最新ID困难
		- 适用场景：计数场景，如统计用户访问量
	- ### 方案四：UUID和GUID
		- 速度超快，全球唯一
		- 缺点：没有顺序性
		- 适用场景：链路追踪
	- ### 方案五：雪花算法生成ID
		- 按照一定规则填充Long的64位: 时间（毫秒级）+集群ID+机器ID+序列号
		- 去中心化生成ID，按时间总体有序
		- 缺点：要求机器时钟同步,需解决 时钟回拨问题
		- 适用场景： 分布式应用下的PK
- ## 发号后的二义性检查
	- 对原始URL，需要检查是否已经存在
	- ### 方案一：直接查询数据库
		- 数据库的主键的短URL，还需要对长URL建立索引，维护成本高
		- 无法支撑高并发下的流量
	- ### 方案二：使用Redis的布隆过滤器
		- 如果 redis bloom filter 不存在，直接生成
		- 如果 redis bloom filter 判断为存在,再查询数据库
- ## 大规模数据及吞吐量的存储
	- ### 表结构
		- ```java
		  // 雪花算法生成的id,主键
		  private Int Id;
		  //原始URL
		  private String SURL;
		  ```
	- 数据容量分治--分库分表
	- 数据吞吐分治--读写分离
- ## 映射模块
	- ### 映射模块的基础功能
		- 转换-- 62进制的短链转换为10进制的主键ID
		- 映射--在数据库中寻找对应的长地址
		- 重定向-- 通过302重定向，将请求转到对应的长地址上
	- ### 映射模块的三级缓存
		- 缓存内容：1. 热门的长链接 2. 最近的长链接
		- 三级缓存：1. Nginx+Lua (在Nginx层，通过Lua脚本读取Redis中的数据)2. 本地缓存 3. Redis
	- ### 映射模块的热点key侦测
-
-
- 原文链接 https://mp.weixin.qq.com/s/U7Ng7rMnodLTIUlGD8bJZw
-