- [[Java 元空间]] 会产生内存溢出吗？#card
  card-last-interval:: -1
  card-repeats:: 0
  card-ease-factor:: 2.5
  card-next-schedule:: nil
  card-last-reviewed:: nil
  card-last-score:: nil
	- 元空间的由来。 {{cloze 从java8+开始，用 元空间 替代了 永久代/方法区}}
	- 元空间的内存 {{cloze 并不使用虚拟机的内存，而是直接使用机器内存}}
	- 出现OOM的原因 {{cloze 加载到内存中的class文件数量太多or体积太大}}
	- 解决办法 {{cloze 增加元空间的大小 `-XX:MaxMetaspaceSize=512m`}}
- 说一下 JVM 的主要组成部分及其作用 #card
	- 类加载系统 {{cloze 根据给定的全限定类名，使用双亲委派模型，由类加载器加载class文件到 方法区}}
	- 运行时数据区 JVM内存模型 {{cloze 分为线程公有的堆、方法区，和线程私有的 虚拟机栈、本地方法栈、程序计数器}}
	- 执行引擎 {{cloze 执行字节码指令。分为 即时编译执行和解释执行。此外，**垃圾收集器** 也在其中}}
	- 本地接口 {{cloze 调用本地方法}}
- 说一下JVM内存模型 #card
	- 画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题
	- 虚拟机栈
		- {{cloze 是线程私有的。每个方法被执行时，都在栈中同步创建一个栈帧}}
		- {{cloze 用于存储 局部变量表(基本数据类型及对象的引用)、操作数栈、动态链接、方法出口等信息}}
		- {{cloze 申请不到足够内存时会抛出OOM异常；栈深度超过规定时会抛出StackOverFlowError}}
	- 程序计数器
		- {{cloze 当前线程所执行的字节码的行号}}
		- {{cloze 一个core只能运行一个线程，多线程是通过轮流切换、分配时间的方式来完成的。这就需要一个记录每个线程执行到哪里}}
	- 本地方法栈
		-
-
-
- {{embed ((63bd4534-d85b-468e-8f13-22c240b38693))}}
- {{embed ((63bd460a-e462-4cab-90c5-e495141648ad))}}
- ## [[Java 堆内存]] 与[[Java 虚拟机栈]] 的区别
	- 物理地址
		- 堆的物理地址分配是不连续的。所以GC时有各种算法
		- 栈的物理地址分配所连续的
	- 内存分别
		- 堆分配的内存在**运行期**确认的，大小不固定，但远大于栈
		- 栈分配的内存大小在**编译器**将确认，大小所固定的
	- 存放的内容
		- 堆存放的所对象实例和数组，更侧重于数据的存储
		- 栈存放了 局部变量、操作数栈、返回结果，更侧重于方法的执行
	- 程序可见度
		- 堆对于整个应用程序都是共享的、可见的
		- 栈是线程私有的
- ## 内存泄漏问题
	- 理论上来说 [[Java GC]]机制可以保证不再被使用的对象被自动回收，自动从内存中清除
	- 导致内存泄漏的根本原因是：**长生命周期**的对象持有**短生命周期**对象的引用而导致不能被回收
- {{embed ((63be8025-29b0-460e-8867-4258e648347e))}}
- ## 如何排查JVM问题
	- 使用`jmap`查看各区域的使用情况
	- 使用`jstack`查看线程的运行情况，关注阻塞的线程、是否出现了死锁
	- 使用`jstat`查看GC情况，特别注意Full GC
	- 使用`visualvm`分析大内存占用，如 短时间内产生的大量小对象，长期的大对象以及长期得不到回收的对象
-
- xxx