- ARISE算法 数据库恢复 原型算法
	- WAL支撑
		- 日志先于数据落盘
		- Steal + No-Force的缓存池管理策略
	- Redo过程是复现历史操作
		- 按照日志记录的内容做回放，恢复到故障发生前的状态
	- Duno过程是记录变更
		- 在 undo 过程中记录 undo 操作到日志中，确保在恢复期间再次出现故障时不会执行多次相同的 undo 操作
- LSN 日志序列号 Log Sequence Numbers
  collapsed:: true
	- WAL中的每条日志记录都需要包含一个全局唯一且一般是单调递增的ID
	- DBMS中的不同部分都需要记录某些相关的LSN信息(不同种类的LSN)
		- |Name|Where|Definition|
		  |flushedLSN|内存|最后落盘的那个 LSN|
		  |pageLSN|page_x|该页page_x的最新修改|
		  |recLSN|page_x|上一次页page_x被flush后的第一个修改|
		  |lastLSN|事务T_i|事务T_i留下的最后一条日志|
		  |MasterRecord|磁盘|上一次打checkpoint点对应的地方|
	- 脏页Flush有关的LSN
		- 被刷新的page都包含pageLSN
		- DBMS会持续追踪flushedLSN
		- 在page_x写入磁盘前，我们必须确保刷入的日志记录至少满足如下条件 `pageLSN_x <= flushedLSN`
			- 比flushedLSN小的pageLSN记录都应该刷入磁盘
			- ![image.png](../assets/image_1720249802168_0.png){:height 415, :width 361}
		- 所有的日志记录都有LSN
		- 一旦事务修改了page中的记录，就要更新相应的pageLSN
		- 每次DBMS将WAL缓冲区写入磁盘，就更新在内存中的flushedLSN
- 事务的提交&回滚操作
	- 前提假设
		- 所有的日志记录都在一个page里面
		- 写入磁盘的操作是原子性的
		- 记录tuples使用的是严格的2PL模式
		- buffer manager使用的是Steal +No-force模式
	- ((6688ef41-9419-49db-90f1-72edc2ed1159))
	- ((6688f069-3102-4273-9ac1-0bb82b9d84a3))
- ---
- Transaction Commit 事务提交
  id:: 6688ef41-9419-49db-90f1-72edc2ed1159
	- 向日志中写入一条`COMMIT`记录
	- 这条`commit`记录之前的所有日志记录，都flush到磁盘
		- flush的过程是连续且同步的写入磁盘
		- 写入的是一张log page中的许多log条目
		- 更新flushedLSN = commit LSN
	- 当此操作成功，再写入一条`TXN-END`记录
		- 这条记录不需要立即flush
	- 整个过程并没有触发 checkpoint制作 或 脏页刷新
- Transaction Abort 事务回滚
  id:: 6688f069-3102-4273-9ac1-0bb82b9d84a3
	- 事务回滚对于ARIES来说是一个特殊的undo操作。
	- 需要在日志记录中增加一个字段:prevLSN
		- prevLSN: 当前事务T1的上一条日志记录
		- 这就构成了一条事务T1的日志记录链表，方便查找事务T1所做的所有操作
	- 在对事务做回滚时，需要把进行过的回滚操作也写入日志，称为CLR(compensation log records)
		- 防止在回滚过程中再次出现故障，导致部分操作被执行多次
	- 回滚完毕后，再写入一条`TXN-END`记录
- CLR 回滚操作日志 compensation log records
	- 一条CLR描述的 先前被更新的记录的undo操作，它包含那条update 记录的所有字段，以及一个undoNext指针
-