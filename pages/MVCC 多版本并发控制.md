- 对数据库中的每一条数据，DBMS都将记录它的多个版本
	- 当写操作执行时，被修改的对象会创建出一个新版本
	- 当读操作执行时，读取的是当前事务开始之前，就已经存在的 最新版本
- 在 ((6666a683-b051-4d25-a4f6-9e91200fafb4)) 中,事务Ti更新了对象a后，其他的事务就没法读这个对象了，直到事务Ti commit; 而MVCC则保留了历史版本，其他事务可以读历史版本而不被阻塞。
- 运行方式
	- 一个全局事务状态表,一个对象A组成的版本链
	- 读取时，只能读取 已提交修改的事务的记录
		- 根据全局事务状态表，判断记录Ai的操作事务Ti是否已经提交
		- 可读取的版本有多条，根据事务的隔离级别来选择读取哪一条
		- ![image.png](../assets/image_1718527803453_0.png){:height 161, :width 277}
	- 写入时，T2需要等到T1的状态变为committed再执行W(A)，因为存在未提交的新版本
		- ![image.png](../assets/image_1718527786455_0.png){:height 156, :width 276}
	- 这个执行调度并不是serializable的，因为T2并没有在T1提交更新的基础上进行操作，因此只依靠MVCC是不能达到调度的串行化的
-