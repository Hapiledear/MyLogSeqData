- 对数据库中的每一条数据，DBMS都将记录它的多个版本
	- 当写操作执行时，被修改的对象会创建出一个新版本
	- 当读操作执行时，读取的是当前事务开始之前，就已经存在的 最新版本
- 在 ((6666a683-b051-4d25-a4f6-9e91200fafb4)) 中,事务Ti更新了对象a后，其他的事务就没法读这个对象了，直到事务Ti commit; 而MVCC则保留了历史版本，其他事务可以读历史版本而不被阻塞。
- 简单来说，MVCC加速了在 读未提交、读已提交、可重复读 三种隔离级别下的读写。但对于记账等严格一致性场景，必须使用锁机制升格到serializable级别。
-
- 运行方式
	- 一个全局事务状态表,一个对象A组成的版本链
	- 读取时，只能读取 已提交修改的事务的记录
		- 根据全局事务状态表，判断记录Ai的操作事务Ti是否已经提交
		- 可读取的版本有多条，根据事务的隔离级别来选择读取哪一条
		- ![image.png](../assets/image_1718527803453_0.png){:height 161, :width 277}
	- 写入时，T2需要等到T1的状态变为committed再执行W(A)，因为存在未提交的新版本
		- ![image.png](../assets/image_1718527786455_0.png){:height 156, :width 276}
	- 这个执行调度并不是serializable的，因为T2并没有在T1提交更新的基础上进行操作，因此只依靠MVCC是不能达到调度的串行化的
- 并发控制协议 Concurrency Control Protocol
	- 只使用MVCC无法做到serializable(可串行化)的隔离级别，因此会和其他一些协议结合在一起
	- ((666d7a5f-c3c6-4b09-a979-303f9cd83008))
	- ((666d8276-2d0b-4ae0-8b13-1e28ba11855b))
	- ((6666a683-b051-4d25-a4f6-9e91200fafb4))
- 版本存储 Version Storage
	- 使用tuple对象的指针建立起一个版本链表
		- 对于正在执行中的事务Ti,可以很方便的找到想要的版本
		- tuple如果有索引
- 垃圾回收 Garbage Collection
- 索引管理 Index Management