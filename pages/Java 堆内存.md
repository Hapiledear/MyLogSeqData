- 堆是JVM内存中最大的一块，由所有线程共享, 是由垃圾收集器管理的内存区域
- 存放的内容如下
	- 句柄池
	  id:: 63be0f36-eaf1-4f67-84b9-d643b432a521
		- 指向实例池中对象实例的指针
		- 指向[[Java 方法区]]中对象类型的指针
	- 对象实例
		- 类生成的对象
		- 基本数据类型的数组
	- 字符串常量池 #常量池
	  id:: 63bbdf17-5b8f-4701-8bca-0097d2434326
		- 自1.7版本开始存放于堆中，原本存放于[[Java 方法区]]
		- 存储的是string的直接引用，是一张table
	- 静态变量
		- 被 static 修饰的变量，原本存放于[[Java 方法区]]
	- 线程分配缓冲区 Thread Local Allocation Buffer
		- 线程私有，但不影响堆的共性
		- 可提升对象分配是的效率--降低并发冲突
- 堆内存的分配策略
  id:: 63be6a8e-383b-47dd-9c41-2a50709409e1
	- 对象优先在Eden区分配，如果Eden没有足够空间，执行一次 ((63be6b6a-8bc6-477a-830f-13fcb1a8a633))
	- 大对象直接进入老年代。避免在Eden区和两个Survivor区之间发生大量的copy( ((63be6a31-b5b0-4ffb-8c95-72fc10fc453a)) )
	- 长期存活的对象进入老年代。新对象经过1次 ((63be6b6a-8bc6-477a-830f-13fcb1a8a633)) 进入Survivor区，之后每经过1次 ((63be6b6a-8bc6-477a-830f-13fcb1a8a633)) 对象年龄+1，直到达到阈值，进入老年代。
	- 动态阈值判断。 年龄 = sum(Survivor区中相同年龄的所有对象大小) > Survivor空间大小/2
	- 空间分配担保。 Survivor区需要移至老年区的对象**平均大小** > 老年区的剩余大小 ，则会进行一次 ((63bd458f-4ddf-4a39-ba1d-4b7d2b7baeae))
	-
- 如何调优
	- `-Xms` 最小堆内存
	- `-Xmx` 最大堆内存
	-
- 如何排查问题
	- [[OOM 内存溢出]]
-
- ## 为什么 ((63bbdf17-5b8f-4701-8bca-0097d2434326)) 被移动到了堆中？
  id:: 63bd4534-d85b-468e-8f13-22c240b38693
  collapsed:: true
	- [[Java 永久代]]在 ((63bd458f-4ddf-4a39-ba1d-4b7d2b7baeae)) 时才会触发，条件苛刻
	- 开发中会有大量字符串被创建，回收效率低导致永久代内存不足
	- 放在堆中，可以及时回收内存