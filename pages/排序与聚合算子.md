- 基于磁盘的DBMS无法将一整张表的数据读入内存，我们仍然需要使用buffer pool实现算法和溢写，并且在算法中最大化利用顺序读写的能力。
- 如果数据量小，可以全部放入内存，然后使用常见的排序算法，如快排；否则，我们就必须付出额外的磁盘IO成本。
- 为何需要排序
	- 表中的数据是无序的，但如下查询场景经常要求数据有序
		- 元素去重`distinct`
		- 数据按bulk Loading存入B+树(大批量数据插入时)
		- 聚合 `group by`
- 外部归并排序 External Merge Sort
  id:: 66cd7b1e-0d77-4145-a82a-92577767c2b9
	- 阶段一：Sorting
		- 划分的数据块大小，可以放入内存，在内存中排好序后，写入磁盘的一个file中
	- 阶段二：Merging
		- 将磁盘的sort-file 合并为一个大的file
	- 以2路外排序为例子。假设数据有N个页大小，buffer pool有B页
		- pass 0:将B页数据读入内存，排序，写回磁盘
		- pass 1,2,3： *每2页*的读取sort-file,开辟3页大小的内存空间(2 for input ,1 for output); 页满后写回磁盘，重复此过程。
	- 推广到一般情况，对于N个页大小的数据，执行X次外排
		- $$X=1+\left \lceil log_2N \right \rceil $$
		- $$IO Cost=2N*X$$
		- eg。对于8页大小的数据进行排序，需要执行 1+3 次。