- {{cards [[Redis面试题]]}}
- 项目中缓存是如何使用的，为什么要用 #card
	- 提高接口性能 {{cloze 缓存查询结果}} 用得最多的是 {{cloze 用户信息查询}} 接口
	- 降低数据库压力 {{cloze 热点数据缓存}}
	- 限流&幂等&分布式锁
	- 一级页面熔断降级 {{cloze 缓存数据，降级后直接取用}}
- 缓存使用不当会带来哪些后果，解决办法 #card
	- 缓存与数据库的双写不一致
	- 缓存雪崩
	- 缓存穿透
	- 缓存击穿
- 在日常项目中用到了哪些Redis数据类型,底层结构是什么样的 #card
	- string
		- {{cloze 普通的kv存储，常用}}
		- 底层结构是 {{cloze 动态字符串SDS}}
	- set
		- {{cloze 集合的交并差操作，比如  你可能认识的人，共同的朋友}}
	- hash
		- {{cloze 层级为1的对象}}
		- {{cloze hash表，采用数组+链表 扩容时采用渐进式rehash}}
	- list
		- {{cloze 用户的粉丝列表，关注列表}} 可基于list实现分页查询
		- 底层结构是 {{cloze 双向无环链表}}
	- zset
		- {{cloze 自定义score排序，比如排行榜机制}}
		- {{cloze 跳跃表，节点按分值大小排序，再按对象大小排序}}
- Redis的过期策略有哪些?数据明明过期了，怎么还占用着内存 #card
	- 定期删除
		- {{cloze 每隔一段时间，删除过期key}} {{cloze 采用随机抽取策略}}
		- 为什么单个key不能到期删除? {{cloze 需要用监视器来负责监视key，虽然内存及时释放，但占用了宝贵的CPU资源}}
	- 惰性删除
		- {{cloze 当我们查询key的时候才对key进行检测}}
	- 内存淘汰机制
		- {{cloze noevivtion}} 直接拒绝
		- {{cloze allkeys-lru}} 所有key中 lru
		- {{cloze allkeys-random}} 所有key中 随机移除
		- {{cloze volatile-lru}} 有过期时间的key中 lru
		- {{cloze volatile-random}} 有过期时间的key中 随机移除
		- {{cloze volatile-ttl}} 有过期时间的key中 移除最早过期时间的key
- 了解Redis的事务机制吗？#card
	- 事务以 {{cloze MUTLI}}命令开始
	- 客户端接收一系列操作，放入队列中
	- 收到 {{cloze EXEC}}命令后，开始顺序执行操作。
	- 监视整个事务相关的key是否早已被修改，如果是则拒绝执行这个事务
	- 执行时不会被其他客户端发送来的命令请求打断
	- 不支持回滚，要么都执行，要么都不执行
- Redis为什么快？#card
	- 基于内存操作
	- 使用单线程， {{cloze 避免线程切换和竞争产生的消耗}}
	- 基于 {{cloze IO多路复用模型}} IO模型 {{cloze 让单个线程高效处理多个连接请求}}
	- {{cloze C语言实现，更加优化的基础数据结构}} 语言、底层数据结构
- Redis是单线程的吗？#card
	-