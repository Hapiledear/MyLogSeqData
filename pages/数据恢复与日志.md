- 恢复算法是一种技术，用来在失败时，确保数据库的一致性、事务的原子性和持久性
- 恢复算法分为两大部分：
	- 发生在事务期间的，用以确保DBMS可从失败中复原。
	- 发生在故障之后进行恢复，确保数据库的状态符合原子性、一致性和持久性
- 故障的级别 Failure Classification
	- DBMS的不同组件依赖于不同的存储设备，而存储设备有如下三类
		- Volatile Storage
		  id:: 6677cbc2-3735-440f-9761-22627c566d33
			- 当断电或程序退出后，数据不会留存
			- 如：各种内存、DRAM、SRAM
		- Non-volatile Storage
		  id:: 6677cbcc-b335-4e44-b96b-ac0c9cac7ffd
			- 当断电或程序退出后，数据依旧存在
			- 如：各种硬盘 HDD、SDD
		- Stable Storage
		  id:: 6677cbd5-d9f5-4713-8a83-a8074fdd8f30
			- 永远不会坏的Non-volatile Storage
- DBMS中的故障分为三级
	- 事务级别的故障 Transaction Failures
		- 逻辑错误 Logical Errors
			- 由于一些程序允许的错误原因，导致事务无法完成
			- 如：用户要求回滚或者OCC的校验阶段发现不可串行而被迫回滚
		- 内部状态错误 Internal State Errors
			- 由于某个错误条件，DBMS必须中止并且重新执行transaction
			- 如：两个事务之间构成死锁，不得不把其中一个回滚
	- 系统级别的故障 System Failures
		- 软件异常 Software Failures
			- DBMS或者OS的bug
		- 硬件异常 Hardware Failures
			- 运行DBMS的机器崩溃了。如：断电
			- Fail-stop假说： ((6677cbcc-b335-4e44-b96b-ac0c9cac7ffd))   硬盘引起的故障不包括在系统故障中。
	- 存储媒介的故障 Storage Media Failures
		- 这类故障一般是无法修复的，数据库开发者无需考虑这些
- Undo/Redo 操作
  id:: 6677ce7d-06d2-4e70-bd88-53668c32cf45
	- Undo: 移除未完成或者abort 事务的影响。
	- Redo：恢复已commit事务，保证其持久性。
	- DBMS如何支持这两个操作，取决于她如何管理缓存池buffer pool
- DBMS要求**事务在commit的时候必须把它所做的更新写入磁盘**,是为Force策略；否则，是No-Force策略
- No-Steal+Force策略
	- 定义
		- ![image.png](../assets/image_1719128535452_0.png){:height 249, :width 478}
		- No-Steal：修改时都会copy一份
		- Force:commit时必须把修改写入磁盘
	- 优点
	  collapsed:: true
		- 回滚时不需要做undo操作，只需把缓存池改回到原来的状态即可
			- 被回滚的事务所做的更新没有被其他已经提交了的事务所连带着写入硬盘
		- 重启恢复的时候也不需要做redo操作
			- 因为事务commit的时候就已经完成了持久化
	- 缺点
	  collapsed:: true
		- 刷盘操作过于频繁，性能不佳
		- 每个事务可修改的数据的量严重受缓存池大小限制
			- 如果有一部分被修改过的页提前被踢出缓存池，那么就破坏了事务的原子性。特别是全表扫描然后更新的这种场景下。
	- 具体实现
		- ((6677d2e6-0f7d-498d-91dc-7046cf0e2a5c))
- Steal+No-Force策略
	- ((6677d4d0-52bd-4ebb-87bf-4011ba257a26))
-
- Shadow Paging
  id:: 6677d2e6-0f7d-498d-91dc-7046cf0e2a5c
	- 会维护两份数据库数据
		- Master：包含所有已经提交事务的数据
		- Shadow：在 Master 之上增加未提交事务的数据变动
	- 正在执行的事务都只将修改的数据写到 shadow copy 中，当事务提交时，再原子地把 shadow copy 修改成新的 master。
		- 为了提高效率，DBMS 不会复制整个数据库，只需要复制有变动的部分即可。
		- ![image.png](../assets/image_1719129058557_0.png){:height 251, :width 415}
	- 优点
		- 新的shadow page在Tx1执行的过程中可以被刷到磁盘中，因为会刷到磁盘里新分配的页，其他事务看不到这些页，直到Tx1提交之后。
		- 因为这个特性，能容纳修改的大小远远超过了buffer pool
	- 缺点
		- 磁盘I/O次数增多，因为在事务进行的过程中就要往磁盘里写数据。
		- 一个shadow page里面可能有成百上千条的数据（MySql 1页=16KB）如果我们只修改数据库文件某个页里的一条数据的话，那么还是要对这整个页做一个拷贝，因此就会有很大的冗余，拷贝的开销不小。
		- 在commit时所做的事情太多
			- 把shadow page都刷入磁盘
			- 修改DB Root
			- 对之前的内存和磁盘里的旧的页做垃圾清理.
		- 容易造成数据的碎片化
			- 清理掉了很多旧页之后，磁盘上出现了外部碎片/空穴（如下所示），数据的存储可能就因此变得不连续
	- SQLite 曾经使用过改进后的Shadow Paging策略
	  collapsed:: true
		- ![image.png](../assets/image_1719129449268_0.png){:height 469, :width 456}
		- 硬盘上journal file里存储的是事务要修改的页的原始版本，commit时会把缓存池里修改后的页刷入磁盘里对应的地方（非jouranl file区）
		- ![image.png](../assets/image_1719129458618_0.png){:height 288, :width 337}
		- 如果刷入Page 2'之后停电了，机器重启后会把journal file加载入缓存，然后把它写入磁盘，这就完成了对断电时未提交的事务的回滚，保证了事务的原子性
		- ![image.png](../assets/image_1719129481177_0.png){:height 324, :width 291}
		- ![image.png](../assets/image_1719129499137_0.png){:height 330, :width 301}
		-
- Write-Ahead Log WAL 预写日志
  id:: 6677d4d0-52bd-4ebb-87bf-4011ba257a26
	- 磁盘中会单独开辟一块区域log File，用于保存事务对于数据的修改操作。
		- 假设日志文件存储在不容易损坏的存储设备上 ((6677cbd5-d9f5-4713-8a83-a8074fdd8f30))
		- 日志中包含足够多的信息来完成  ((6677ce7d-06d2-4e70-bd88-53668c32cf45))
	- DBMS必须先完成预写日志的持久化，再完成缓存池里dirty page的持久化
	- WAL 协议
		- DBMS将所有的事务日志存放在 ((6677cbc2-3735-440f-9761-22627c566d33)) 中，通常是内存中的一段专用空间。
		- 在将数据页落盘前，所有的日志记录必须先落盘
		- 直到所有的日志记录都被写入 ((6677cbd5-d9f5-4713-8a83-a8074fdd8f30)),事务Tx1才被认为是commit完成。
		- 事务开始时会写入一个