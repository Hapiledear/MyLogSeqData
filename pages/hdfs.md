- 更好的支持分布式计算 #分布式系统
- 存储模型
	- ![image.png](../assets/image_1646554841348_0.png)
	- 切割过程，会将有实际意义的字符(单词，中文，符号)切分到两个文件中，如何再拼接起来？
	- 切分为块的目的，是为了分散在多个节点中
	- 创建副本，是为了解决可靠性和性能的问题, #数据冗余 #容灾
	- 支持修改会怎么样？在修改的地方，所对应的块会变大。在它之后的块的偏移量就不对了。只能将溢出数据逐渐下移到最后一块，造成大量网络传输。这是不必要的。 #泛洪操作
- 架构设计 #主从结构
	- 主从(Master/Slaves)架构
	- 由一个[[NameNode]](主) 和一些[[DataNode]](从) 组成,包含 文件[[数据]](data) 和文件 [[元数据]] (metadata)
		- NameNode负责存储和管理文件元数据,并维护一个文件目录树
		- DataNode负责存在文件数据(block-块),并提供block的读写
		- DataNode与NameNode之间维持心跳链接,并汇报自己持有的block信息
	- Client 向NameNode交互文件元数据(metadata); 向DataNode交互文件数据(data)
	- ![image.png](../assets/image_1646968875633_0.png)
- 角色功能
	- 角色 = 进程
	- [[NameNode]]
	- [[DataNode]]
- [[元数据]]\持久化 #持久化技术
  id:: 622c4b81-70b0-4b12-adfc-fc6de273d0d4
	- EditsLog 日志文件
		- 体积小，记录少时有优势
	- FsImage 快照
		- 如果有更快的滚动更新时间点(更新间隔短)
	- ![image.png](../assets/image_1647071489662_0.png)
	- 最近时间点的FsImage + 增量EditsLog
		- current = 10 FI=9  EL =9 to 10
	- FsImage的滚动更新方案
		- 由 [[NameNode]] 8点溢写，9点溢写 ...
		- [[NameNode]] 第一次开启时写溢出FsImage = 8点,之后使用EitsLog=8 to 9，将这些记录更新到8点的FI中，就变成了9点 的FI
- 安全模式
- 副本放置策略
- 读写流程
- 安全策略