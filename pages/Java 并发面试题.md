- 并发中的三大问题是如何产生的，都是如何解决的? #card #Java并发 /cloze
	- 原子性
		- {{cloze `i++` 一行代码被编译为机器指令时可能是多步操作}}
		- {{cloze CAS , synchroize，显示锁}}
	- 有序性
		- {{cloze CUP指令重排序，JVM编译重排序}}
		- {{cloze CPU的内存屏障 As-if-Serial规则，JMM的内存屏障、Happens-Before规则}}
	- 可见性
		- {{cloze CUP 的物理缓存结构,JMM内存模型也有缓存}}
		- {{cloze CUP层级的MESI协议，JMM的八种操作规范}}
- volatile关键字的原理及其实战 #card #Java并发
	- 解决了两大问题 {{cloze 可见性和禁止指令重排}} 通常搭配atomic类来实现 {{cloze 原子性}}
	- 实践 单例模式中 {{cloze volatile修饰instance. 保证其写操作发生在读之前}}
- volatile能将非原子操作变成原子操作吗 #card #Java并发
	- 在32位的机器上，long和double分为了两部分 高位和低位。因此建议用volatile修饰
	- 但更建议JVM实现时将这种操作视为原子性的
- synchronized (简称 同步)的原理 #card #Java并发
	- 通过 {{cloze `monitorEnter` 和`monitorExit`}} 指令，进行加锁和释放锁。是可重入的
	- {{cloze 遵循happends-before规则，写在读之前}} ，保证可见性
	- 上锁过程 {{cloze 在对象头中，记录锁的类型 和 指向栈中的锁记录指针}}
	- 如果没有获取到锁，则会 {{cloze 让线程自旋等待，并不放弃CPU的执行时间}}
- synchronized的锁升级机制 #card #Java并发
	- 锁消除 无锁
		- {{cloze 在编译时明显检测到不会被其他线程访问到}}
	- 偏向锁
		- 2个条件 {{cloze 无竞争情况下}} {{cloze 对象头的threadId空间可用}}
		- 如何设置 {{cloze CAS操作 threadId=this}}
		- 竞争加剧 {{cloze 膨胀为轻量级锁}}
	- 轻量级锁
		- 栈和锁对象的结构 {{cloze 栈中增加 LockRecord 指向锁对象}} {{cloze 对象头的一部分保存 LockRecord指针}}
		- CAS 自适应自旋 {{cloze 根据上次获得锁的时间与结果自动调整 次数和等待时长}} {{cloze 进行空转，并未放弃时间片}}
	- 重量级锁 监视器(Monitor)机制
		- 同步功能
			- {{cloze 抢锁线程->竞争队列->等待队列->队头线程参与竞争->持有锁->被阻塞，进入waitSet->被唤醒，进入等待队列}}
		- 协作机制
			- 持有许可的线程可以 {{cloze 主动放弃许可进入阻塞}} {{cloze 发送信号，唤起阻塞线程}}
- synchronized和volatie的区别  #card #Java并发
	- 修饰的地方 {{cloze volatile是变量修饰,synchronized可以修饰类、方法、变量}}
	- 解决的问题 {{cloze volatile 保证的是有序性和可进行，不能保证原子性，synch 保证的是可见性(Happends-before)和原子性}}
	- 线程是否阻塞 {{cloze volatie不会造成阻塞 synch 可能造成阻塞}}
	- 是否被编译优化 {{cloze volatile不会被编译优化，synch可以被优化}}
	- 实际开发中 {{cloze synch比volatile用得多一点，volatile需要搭配automit类使用}}
- 什么是CAS #card #Java并发
	- compare and swap 比较并交换
	- 实现,是否加锁 {{cloze 内存位置v 预期原值A和新值B ，如果内存值=A 那么将内存值改为B}} {{cloze 不加锁，但会自旋一定次数}}
	- 实现 {{cloze atomic下的类大多是使用CAS操作来实现的}}
- CAS会产生什么问题以及解决办法 #card #Java并发
	- ABA问题
		- {{cloze 用链表的例子更直观}}
		- {{cloze 使用带版本号的CAS操作}}
	- 开销大
		- {{cloze 竞争激烈的情况下，自旋概率大，从而浪费更多CPU资源}}
		- {{cloze 分散操作热点 LongAdder}} {{cloze 放入一个队列中排队，降低争用 AQS}}
	- 只能保证一个共享变量的原子操作
		- {{cloze 将两个变量放入一个对象中}} {{cloze 上锁}}
- Lock与synchronize的区别 #card #Java并发
	- 实现方式
		- {{cloze Lock基于Java类实现，易于扩展，功能丰富}} {{cloze synch基于对象头实现，无法自定义}}
	- 公平性
		- {{cloze Lock有公平和非公平两种}} {{cloze synch是非公平的}}
	- 等待通知机制
		- {{cloze synch通过wait/notify 实现}} {{cloze Lock通过 实现}}
	-
- 可重入锁的实现原理
- AQS是什么，抢锁过程
- ConcurrentHashMap的原理
- synchronize与ConcurrentHashMap的区别
- CopyOnWriteArrayList是什么，实践场景
- 阻塞队列BlockingQueue的实现原理
- 什么是原子操作
- java中有哪些原子类
- atomic的原理
- final类 不可变对象 描述
- ThreadLocal原理
- 线程池调度流程&各项参数
- 线程池调优策略