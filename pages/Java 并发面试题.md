- 并发中的三大问题是如何产生的，都是如何解决的? #card #Java并发 /cloze
	- 原子性
		- {{cloze `i++` 一行代码被编译为机器指令时可能是多步操作}}
		- {{cloze CAS , synchroize，显示锁}}
	- 有序性
		- {{cloze CUP指令重排序，JVM编译重排序}}
		- {{cloze CPU的内存屏障 As-if-Serial规则，JMM的内存屏障、Happens-Before规则}}
	- 可见性
		- {{cloze CUP 的物理缓存结构,JMM内存模型也有缓存}}
		- {{cloze CUP层级的MESI协议，JMM的八种操作规范}}
- volatile关键字的原理及其实战 #card #Java并发
	- 解决了两大问题 {{cloze 可见性和禁止指令重排}} 通常搭配atomic类来实现 {{cloze 原子性}}
	- 实践 单例模式中 {{cloze volatile修饰instance. 保证其写操作发生在读之前}}
- volatile能将非原子操作变成原子操作吗 #card #Java并发
	- 在32位的机器上，long和double分为了两部分 高位和低位。因此建议用volatile修饰
	- 但更建议JVM实现时将这种操作视为原子性的
- synchronized的原理 #card #Java并发
- synchronized的锁升级机制 #card #Java并发
- synchronized和volatie的区别  #card #Java并发
- 什么是CAS #card
- CAS会产生什么问题 #card
- Lock与synchronize的区别
- 可重入锁的实现原理
- AQS是什么，抢锁过程
- ConcurrentHashMap的原理
- synchronize与ConcurrentHashMap的区别
- CopyOnWriteArrayList是什么，实践场景
- 阻塞队列BlockingQueue的实现原理
- 什么是原子操作
- java中有哪些原子类
- atomic的原理
- final类 不可变对象 描述
- ThreadLocal原理
- 线程池调度流程&各项参数
- 线程池调优策略